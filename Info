## Концепция проекта: Система интеллектуального управления зданиями и пожарной безопасностью

### 1. Назначение и основная идея

Проект представляет собой **систему с интеллектуальным интерфейсом на естественном языке** для учета арендуемых помещений и мониторинга состояния пожарных датчиков в многокорпусном комплексе.

**Ключевая инновация:** Полный отказ от классического графического интерфейса с формами и кнопками в пользу диалога с **ИИ-ассистентом (Nanobot)**. Пользователь взаимодействует с системой через текстовые или голосовые запросы на обычном языке (например: *«Где находится офис компании "СтартТех"?»* или *«Покажи все неисправные датчики в корпусе Б»*). Система понимает запрос, находит информацию и возвращает понятный ответ, дополняя его визуализацией на схемах этажей при необходимости.

### 2. Архитектурный принцип: «Безопасный интеллект»

**Ядро взаимодействия — фреймворк Nanobot**, выполняющий роль высокоинтеллектуального посредника между пользователем и системой.

**Фундаментальный принцип:** Nanobot — **только интеллектуальный посредник. Прямого доступа к базе данных (PostgreSQL) у него нет.** Всё его взаимодействие с данными и логикой осуществляется исключительно через строго описанный **RESTful API**, предоставляемый Python-бэкендом. Это гарантирует безопасность, контроль и стабильность работы с критическими данными.

**Аналогия:** Nanobot — это **гениальный аналитик без права подписи**. Он может:
*   Понимать сложные задачи, поставленные руководителем (пользователем).
*   Составлять детальные планы их решения.
*   Формально запрашивать (через API) конкретные отделы компании (бэкенд) предоставить необходимые справки и данные.
*   Анализировать полученные ответы и красноречиво оформлять итоговый отчет для руководителя.

Но он **не может** сам войти в архив (БД) или отдать приказ бухгалтерии. Все исполнительные действия выполняются через официальные, контролируемые каналы (API бэкенда).

### 3. Компоненты системы и поток данных

#### 3.1. Хранилище данных (PostgreSQL)
Сервер PostgreSQL хранит всю структурированную информацию:
*   **Корпуса, этажи, помещения** (с привязкой планов-схем).
*   **Арендаторы** и их связь с помещениями.
*   **Пожарные датчики** (тип, серийный номер, местоположение, **ручной статус** — «норма», «неисправен», «тревога» и т.д.).

#### 3.2. Исполнительный слой и шлюз данных (Python Backend & API)
Серверное приложение на Python, которое является **центральным хабом** системы:
*   **Предоставляет RESTful API** для всех операций с системой. Этот API — **единственный** способ взаимодействия с данными для внешних компонентов, включая Nanobot.
*   **Управляет бизнес-логикой**, валидирует запросы и выполняет все запросы к базе данных PostgreSQL.
*   **Служит шлюзом безопасности**, изолирующим БД.
*   **Генерирует визуализации** (например, подсвечивает нужное помещение на схеме этажа) по запросу.

#### 3.3. Интеллектуальный слой (Nanobot Agent)
Локально развернутый ИИ-агент на базе фреймворка Nanobot (работает на **NVIDIA GeForce RTX 5090**). Это **автономный сервис**, который общается с системой исключительно через API бэкенда. Его задачи:
1.  **Понимание намерения (NLU):** Анализ запроса пользователя на естественном языке.
2.  **Планирование и Оркестрация:** Определение последовательности вызовов **API бэкенда** (из предоставленного ему описания — промпта или спецификации инструментов) для получения ответа.
3.  **Синтез ответа:** Преобразование структурированных данных, полученных от API, в связный, удобочитаемый ответ для пользователя.

#### 3.4. Интерфейс взаимодействия (Frontend / Клиент)
Канал, через который пользователь инициирует общение. Возможные варианты:
*   **Telegram-бот:** Наиболее гибкий вариант, поддерживающий текст, голосовые сообщения и отправку изображений (схем). Бот общается с Python-бэкендом.
*   **Десктоп-приложение:** Созданное на Python. Общается с Python-бэкендом по внутреннему протоколу.

### 4. Принцип работы (Детальный поток данных)

**Ключевой цикл:** `Пользователь -> Клиент -> Nanobot -> Бэкенд -> База Данных -> Бэкенд -> Nanobot -> Клиент -> Пользователь`

1.  **Запрос:** Пользователь отправляет текстовое или голосовое сообщение через клиентское приложение (например, Telegram-бот).
2.  **Перенаправление к ассистенту:** Клиент отправляет запрос на специальный эндпоинт Python-бэкенда (например, `/api/query`). **Бэкенд перенаправляет чистый текст запроса локальному экземпляру Nanobot.**
3.  **Анализ и планирование (Nanobot):** Nanobot анализирует запрос, сверяется со своим набором доступных `tools` (описанием API бэкенда) и возвращает **структурированный план действий** в виде вызова конкретного API-метода с параметрами (например, JSON: `{"function": "find_tenant", "arguments": {"name": "СтартТех"}}`).
4.  **Исполнение плана (Бэкенд):** Python-бэкенд получает структурированный запрос от Nanobot, **валидирует параметры**, вызывает **соответствующий внутренний метод** (например, для поиска арендатора в БД через SQLAlchemy) и получает сырые данные из PostgreSQL.
5.  **Циклическое взаимодействие (Опционально):** Для сложных запросов бэкенд может отправить промежуточный ответ (данные от БД) обратно Nanobot. Тот анализирует их, планирует следующий шаг (например, запросить план этажа) и снова вызывает API бэкенда. Этот цикл повторяется, пока не будет собрана вся информация.
6.  **Формирование финального ответа (Nanobot):** Когда все необходимые данные получены, бэкенд отправляет их финальным пакетом Nanobot. Nanobot преобразует структурированные данные (списки, ID, статусы) в ясный текст на естественном языке (например: *«Офис компании "СтартТех" находится в Корпусе 1, на 3 этаже, помещение 310.»*).
7.  **Доставка и визуализация (Бэкенд -> Клиент):** Бэкенд получает текстовый ответ от Nanobot. Если запрос подразумевал визуализацию (поиск помещения), бэкенд **параллельно** генерирует или извлекает схему этажа с подсветкой и упаковывает её вместе с текстом.
8.  **Отображение:** Клиентское приложение получает от бэкенда итоговый пакет (текст + изображение) и отображает его пользователю.

### 5. Целевая аудитория и сценарии использования

*   **Служба безопасности / Инженеры:** Мгновенный мониторинг состояния пожарной системы голосовыми командами во время обхода. *«Какие датчики в тревоге на 5 этаже? Покажи на схеме.»*
*   **Менеджеры по аренде / Администрация:** Быстрый поиск информации об арендаторах. *«Найди все помещения, которые освобождаются в следующем месяце»* или *«Где все офисы арендатора "Инновация"?»*.
*   **Сервисные службы:** Планирование работ на основе статусов оборудования. *«Составь список помещений с датчиками в статусе "требует обслуживания" для корпуса 1.»*

### 6. Технологический стек

*   **Бэкенд и API:** Python (FastAPI / Flask), SQLAlchemy (ORM), Pillow (для работы с изображениями).
*   **База данных:** PostgreSQL.
*   **ИИ-агент:** Фреймворк **Nanobot**, работающий с локальной LLM (например, Qwen2.5, Llama 3.2) на **NVIDIA RTX 5090**.
*   **Клиент:** Python (aiogram для Telegram Bot API / библиотеки для GUI).
*   **Инфраструктура:** Выделенный сервер с белым IP-адресом, Docker (для изоляции сервисов).

### 7. Ключевые преимущества

1.  **Естественность взаимодействия:** Не нужно учить интерфейс, достаточно уметь формулировать задачу.
2.  **Безопасность и контроль:** Критическая бизнес-логика и данные полностью изолированы в бэкенде. Nanobot имеет доступ только к строго определенным API-методам.
3.  **Локальность и скорость:** ИИ-модель работает локально на мощной видеокарте, что обеспечивает мгновенный отклик, конфиденциальность данных и независимость от облачных сервисов.
4.  **Гибкость запросов:** Возможность задавать комплексные вопросы, объединяющие данные об аренде и безопасности, которые в классической системе потребовали бы ручной сборки отчетов.
5.  **Модульность и масштабируемость:** Четкое разделение на интеллектуальный слой (Nanobot), слой логики (бэкенд) и слой данных (БД) позволяет независимо развивать и заменять каждый компонент.
